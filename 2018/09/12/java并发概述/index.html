<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>java并发概述 | Tech</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="自己的理解- 全貌这两天看了那本书《并发编程实战》以及一些相关的文章， 对并发编程有了一点理解。">
<meta name="keywords" content="java,并发">
<meta property="og:type" content="article">
<meta property="og:title" content="java并发概述">
<meta property="og:url" content="http://yoursite.com/2018/09/12/java并发概述/index.html">
<meta property="og:site_name" content="Tech">
<meta property="og:description" content="自己的理解- 全貌这两天看了那本书《并发编程实战》以及一些相关的文章， 对并发编程有了一点理解。">
<meta property="og:locale" content="default">
<meta property="og:image" content="c:/developer/blog/zyhnjust.github.io/source/_posts/java%E5%B9%B6%E5%8F%91%E6%A6%82%E8%BF%B0/2615789-0e32f116bae6062e.png">
<meta property="og:image" content="http://yoursite.com/2018/09/12/java并发概述/2615789-0e32f116bae6062e.png">
<meta property="og:updated_time" content="2018-10-06T09:39:23.574Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java并发概述">
<meta name="twitter:description" content="自己的理解- 全貌这两天看了那本书《并发编程实战》以及一些相关的文章， 对并发编程有了一点理解。">
<meta name="twitter:image" content="c:/developer/blog/zyhnjust.github.io/source/_posts/java%E5%B9%B6%E5%8F%91%E6%A6%82%E8%BF%B0/2615789-0e32f116bae6062e.png">
  
    <link rel="alternate" href="/atom.xml" title="Tech" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Tech</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-java并发概述" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/12/java并发概述/" class="article-date">
  <time datetime="2018-09-12T05:43:57.000Z" itemprop="datePublished">2018-09-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/面试/">面试</a>►<a class="article-category-link" href="/categories/面试/java/">java</a>►<a class="article-category-link" href="/categories/面试/java/并发/">并发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      java并发概述
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
	    
<div id="toc">
  <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#自己的理解-全貌"><span class="toc-text">自己的理解- 全貌</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#问题的由来"><span class="toc-text">问题的由来</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何解决这个问题呢"><span class="toc-text">如何解决这个问题呢</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工具模块以及使用"><span class="toc-text">工具模块以及使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#同步容器类"><span class="toc-text">同步容器类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#并发容器"><span class="toc-text">并发容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#同步工具类"><span class="toc-text">同步工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CountDownLatch"><span class="toc-text">CountDownLatch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FutureTask"><span class="toc-text">FutureTask</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#信号量-Semaphore"><span class="toc-text">信号量 Semaphore</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#栅栏-Barrier-CyclicBarrier"><span class="toc-text">栅栏 Barrier CyclicBarrier</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关于显示锁"><span class="toc-text">关于显示锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程池"><span class="toc-text">线程池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java-内存模型"><span class="toc-text">java 内存模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#其他的ms-问题"><span class="toc-text">其他的ms 问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结以及下一步"><span class="toc-text">小结以及下一步</span></a></li></ol></li></ol>
</div>

        <h1 id="自己的理解-全貌"><a href="#自己的理解-全貌" class="headerlink" title="自己的理解- 全貌"></a>自己的理解- 全貌</h1><p>这两天看了那本书《并发编程实战》以及一些相关的文章， 对并发编程有了一点理解。 </p>
<a id="more"></a> 
<h2 id="问题的由来"><a href="#问题的由来" class="headerlink" title="问题的由来"></a>问题的由来</h2><ul>
<li>单线程是没有并发问题的。 但是为了适应性能的要求以及多核cpu的兴起， 多线程应运而生。 </li>
<li>如果是多线程中的某个线程内存持有的变量， 换句话来说就是无状态的方法， 也是没有并发问题的。 </li>
<li>如果线程之间有了共享的数据， 变量或者别的什么， 那么就有可能有并发的问题。 比如说， 我们需要对类内部变量加1. 线程A拿了这个变量， 而B不知道A拿走了， 也拿走了加一， 问题在于拿到的是A 还没有加1的值。那么当大家把这个值放回去的时候， 发现你的修改已经丢失了。 </li>
<li style="list-style: none"><input type="checkbox"> 实例</li>
<li>整理一下带来的问题， 首先 </li>
<li><ol>
<li>是安全的问题， 也就是刚才实例中的两个线程同时修改， 结果并不是期待中的结果。 - 抽象一下， 主要是多个线程对于共享并且可变的状态的访问。 </li>
</ol>
</li>
</ul>
<ul>
<li><ul>
<li>这里有一个线程安全的定义： 当多个线程访问某个类的时候， 不管运行时环境采取何种调度方式. 或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或者协同，这个类都可以表现出正确的行为， 那么这个类就是线程安全的。</li>
</ul>
</li>
<li><ol start="2">
<li>活跃性问题。 就是说某些情况甚至会造成死锁等情况发生， 这样的话系统的服务造成了中断。 </li>
</ol>
</li>
<li><ol start="3">
<li>性能问题。 是说在处理这些并发问题的时候， 还需要考虑性能的影响， 性能影响的原因是线程的切换会使得调度的消耗增多。 cpu 更多的在调度而不是在处理实际的任务。 </li>
</ol>
</li>
</ul>
<h2 id="如何解决这个问题呢"><a href="#如何解决这个问题呢" class="headerlink" title="如何解决这个问题呢"></a>如何解决这个问题呢</h2><ol>
<li>首先如果方法是无状态的， 自然是线性安全的。 </li>
<li>原子性。 如果我们要加个count， 那么下面的代码就不是线性安全的。 </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private long count = 0; </span><br><span class="line"></span><br><span class="line">public void service(ServletRequest req, ServletResponse res)</span><br><span class="line">		throws ServletException, IOException &#123;</span><br><span class="line">	BigInteger i = extractFromRequest(req);</span><br><span class="line">	BigInteger[] factors = factor(i);</span><br><span class="line">	++count;</span><br><span class="line">	encodeIntoResponse(res, factors);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用AtomicLong 的话， 这个count 增加的时候是原子操作， 所以这样就是线程安全的。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private final AtomicLong count = new AtomicLong(0); </span><br><span class="line"></span><br><span class="line">public void service(ServletRequest req, ServletResponse res)</span><br><span class="line">		throws ServletException, IOException &#123;</span><br><span class="line">	BigInteger i = extractFromRequest(req);</span><br><span class="line">	BigInteger[] factors = factor(i);</span><br><span class="line">	count.incrementAndGet();</span><br><span class="line">	encodeIntoResponse(res, factors);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>如果service中不只是一个操作， 比如get， 然后set. 虽然可能每一步都是线程安全的， 但是两者中间可能是有别的线程插入， 这样的话就不是线程安全的。 </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(vector1.contrains(123))</span><br><span class="line">&#123;</span><br><span class="line">    vetor1.add(e2)      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决办法是用synchronized. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void synchronized service(ServletRequest req, ServletResponse res)</span><br><span class="line">		throws ServletException, IOException &#123;</span><br><span class="line">	BigInteger i = extractFromRequest(req);</span><br><span class="line">	BigInteger[] factors = factor(i);</span><br><span class="line">	count.incrementAndGet();</span><br><span class="line">	encodeIntoResponse(res, factors);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重入 - 这个是顺便讲一下的。 就是说线程A 拿到了方法1的锁， 如果再次进去方法1， 是可以的。 否则会有问题。 比如如果子类继承了这个方法， super.parentMethod()  就无法拿到锁了。 所以syncrhonized 是可重入的。 </p>
<ol start="4">
<li><p>带来了性能的问题， service 只能由一个线程来用， 这样性能受了太大的影响。<br>解决： 可以根据业务逻辑， 对其中的一些语句用synchronized的来修饰。 </p>
</li>
<li><p>关于可见性。刚才其实只是想解决共享状态原子性的问题。 实际上， 并发问题除了原子性， 还有可见性。<br>原子性是否我对这个状态的处理不会受到任何其他线程的影响， 而可见性呢则是我修改了的状态的结果， 别的线程也是可以看到的。 一个常用的场景是，主线程把值置为true， 子线程根据这个值得true false 做操作。 如果没有任何的处理， 那么子线程是看不到这个结果的。 </p>
</li>
</ol>
<p>自己写了程序跑， 其实没有见到错误的结论， 不确定是否在java8 有了什么优化。<br>TODO</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private static class ReaderThread extends Thread&#123;</span><br><span class="line">	public void run()&#123;</span><br><span class="line">		while(!ready)</span><br><span class="line">			System.out.println(ready);</span><br><span class="line">			Thread.yield();</span><br><span class="line">		System.out.println(number);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	// TODO Auto-generated method stub</span><br><span class="line">	new ReaderThread().start();</span><br><span class="line">	number=42;</span><br><span class="line">	ready=true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决这个问题</p>
<ul>
<li>可以加锁。 加了锁之后呢， 在第一个线程做了这个事情时候， 第二个线程开始做。 既解决了原子性， 也解决了可见性。 这里怎么弄呢， 可以把两个变量都隐藏， 只是暴露get set， 然后在这两个方法上面加锁即可。 </li>
<li>另外可以volatile </li>
<li><ul>
<li>volatile的要点在于。 两个线程被cpu 执行的时候， 每个cpu 有自己的寄存器的， 寄存器肯定是比内存快的。 可见性出现的元就是， 线程A cpu的改动放在自己的寄存器缓存， 而B 读的时候是看不到A的改动的。 </li>
</ul>
</li>
<li><ul>
<li>Volatile 做的事情是读的时候直接去内存读取。 而关于是否因为这个而直接写到内存， 不太清楚。 但是它保证的是一个线程的改动可以被别的线程立刻感知。 </li>
</ul>
</li>
<li><ul>
<li>volatile 是一种较弱的锁行为。 其实没有锁， 只是可见性。 </li>
</ul>
</li>
</ul>
<ol start="6">
<li>ThreadLocal </li>
</ol>
<p>这个关键词是什么意思， thread 自己存了一个备份。 而不是share的那个。 例子。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadLocalExample &#123;</span><br><span class="line"></span><br><span class="line">    public static class MyRunnable implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        private ThreadLocal threadLocal = new ThreadLocal();</span><br><span class="line"></span><br><span class="line">        public void run() &#123;</span><br><span class="line">            threadLocal.set((int) (Math.random() * 100D));</span><br><span class="line">//            try &#123;</span><br><span class="line">//            Thread.sleep(2000);</span><br><span class="line">//            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">//</span><br><span class="line">//            &#125;</span><br><span class="line">            System.out.println(threadLocal.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         MyRunnable sharedRunnableInstance = new MyRunnable();</span><br><span class="line">         Thread thread1 = new Thread(sharedRunnableInstance);</span><br><span class="line">         Thread thread2 = new Thread(sharedRunnableInstance);</span><br><span class="line">         thread1.start();</span><br><span class="line">         thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="工具模块以及使用"><a href="#工具模块以及使用" class="headerlink" title="工具模块以及使用"></a>工具模块以及使用</h2><h3 id="同步容器类"><a href="#同步容器类" class="headerlink" title="同步容器类"></a>同步容器类</h3><ul>
<li>Vector 和 Hashtable 这两个呢， 本身是线程安全的， 但是呢， 如果是复合操作， 还是有可能有问题的。 比如这个代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static Object getLast(Vector list)&#123;</span><br><span class="line">	int lastIndex = list.size()-1;</span><br><span class="line">	return list.get(lastIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void deleteLast(Vector list)&#123;</span><br><span class="line">	int lastIndex = list.size()-1;</span><br><span class="line">	list.remove(lastIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的话有时候会抛出exception， ArrayIndexOutOfBoundsException。 因为有的时候另外的线程把它删除了，这里就拿不到了。<br>解决办法呢， 可以在两个组合上加一个锁。 如下。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static Object getLast(Vector list)&#123;</span><br><span class="line">	synchronized(list)&#123;</span><br><span class="line">		int lastIndex = list.size()-1;</span><br><span class="line">		return list.get(lastIndex);			</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void deleteLast(Vector list)&#123;</span><br><span class="line">	synchronized(list)&#123;</span><br><span class="line">		int lastIndex = list.size()-1;</span><br><span class="line">		list.remove(lastIndex);			</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种情况是隐形的， 比如说字串连接， 比如你打印一个东西， 用到tostring， 这样的话呢还是会抛exception。 </p>
<h3 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h3><ul>
<li>ConcurrentHashMap</li>
</ul>
<p>ConcurrentHashMap使用了线程锁分段技术，每次访问只允许一个线程修改哈希表的映射关系，所以是线程安全的<br>另外还增加了一些别的操作， 比如若没有则添加， 这样呢就不需要为这两个操作再加一个锁。 </p>
<ul>
<li>ConpyOnWriteArrayList</li>
</ul>
<p>每次修改都会创建并且发布一个新的容器副本， 从而实现可变性。 读呢则是原来的容器， 从而就避免了线程的冲突。 </p>
<h3 id="同步工具类"><a href="#同步工具类" class="headerlink" title="同步工具类"></a>同步工具类</h3><p>下面几种常用的工具。 </p>
<ul>
<li>什么意思， 使用场景。 </li>
<li>使用实例</li>
<li>注意事项如果有的话</li>
</ul>
<h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><ul>
<li>场景是说一个线程想等其他的线程做完了再做。 这是一种闭锁。 </li>
<li>比如另外一个情况，希望主线程做了之后，其他线程再开始做。 </li>
<li><ul>
<li>不过可以把这个主线程的事情先做， 再创建好了。 这个其实不一定用countdown。</li>
</ul>
</li>
<li></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">work:</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		try &#123;</span><br><span class="line">			startSignal.await();</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + &quot;_start&quot;);</span><br><span class="line">			doWork();</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + &quot;_Done&quot;);</span><br><span class="line">			endSignal.countDown();</span><br><span class="line">		&#125;catch (InterruptedException ex) &#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	void doWork() &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			Thread.sleep(2000);</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			// TODO Auto-generated catch block</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">main:</span><br><span class="line">		CountDownLatch startSignal = new CountDownLatch(1);</span><br><span class="line">		CountDownLatch endSignal = new CountDownLatch(N);</span><br><span class="line">		</span><br><span class="line">		for(int i=0; i&lt; N; i++) &#123;</span><br><span class="line">			new Thread(new Worker(startSignal, endSignal)).start();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;main start&quot;);</span><br><span class="line">		startSignal.countDown();</span><br><span class="line">		System.out.println(&quot;main ip&quot;);</span><br><span class="line">		try &#123;</span><br><span class="line">			endSignal.await();</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			// TODO Auto-generated catch block</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;main end&quot;);</span><br></pre></td></tr></table></figure>
<h4 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h4><p>主线程等待所有子线程返回。 并且可以有回复的消息可以处理。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">MyCallable call = new MyCallable(1000);</span><br><span class="line">FutureTask&lt;String&gt; futureTask= new FutureTask&lt;String&gt;(call);</span><br><span class="line"></span><br><span class="line">MyCallable call2 = new MyCallable(2000);</span><br><span class="line">FutureTask&lt;String&gt; futureTask2= new FutureTask&lt;String&gt;(call2);</span><br><span class="line"></span><br><span class="line">ExecutorService executor = Executors.newFixedThreadPool(2);</span><br><span class="line">executor.execute(futureTask);</span><br><span class="line">executor.execute(futureTask2);</span><br><span class="line"></span><br><span class="line">while(true) &#123;</span><br><span class="line">	try &#123;</span><br><span class="line">		if(futureTask.isDone() &amp;&amp; futureTask2.isDone() ) &#123;</span><br><span class="line">			System.out.println(&quot;All are done!&quot;);</span><br><span class="line">			executor.shutdown();</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		if(futureTask.isDone()) &#123;</span><br><span class="line">			System.out.println(&quot;featuretask 1 output= &quot; + futureTask.get());</span><br><span class="line">			System.out.println(&quot;wait for futuretask2&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		if(futureTask2.isDone()) &#123;</span><br><span class="line">			System.out.println(&quot;featuretask 2 output= &quot; + futureTask2.get());</span><br><span class="line">			System.out.println(&quot;wait for futuretask1&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;catch(Exception e) &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">worker：</span><br><span class="line">class MyCallable implements Callable&#123;</span><br><span class="line"></span><br><span class="line">	private int waitTime;</span><br><span class="line">	</span><br><span class="line">	public MyCallable(int timeMillis) &#123;</span><br><span class="line">		this.waitTime=timeMillis;</span><br><span class="line">	&#125;</span><br><span class="line">	public Object call() throws Exception &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		System.out.println(Thread.currentThread().getName() + &quot;call&quot;);</span><br><span class="line">		return Thread.currentThread().getName();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="信号量-Semaphore"><a href="#信号量-Semaphore" class="headerlink" title="信号量 Semaphore"></a>信号量 Semaphore</h4><ul>
<li>基本逻辑就是用了一个东西控制资源同时使用量。 如果没有拿到， 就等。 </li>
<li>比如一个线程池， 如果用信号量来控制数目， semaphone 和 池子的大小一致， 这样的话如果没有资源的话， 就会阻塞在那里， 而不是直接拒绝。 </li>
<li><p>另外的， 其实更简单的办法用blockingQueue 也是一样的。 </p>
</li>
<li><p>原理就是信号量维护着一个许可证的池子， 如果有人acquire就减一， release 就加一。 如果没有了就等在这里， 知道中断或者有了资源。 </p>
</li>
<li><ul>
<li>公平锁</li>
</ul>
</li>
<li><ul>
<li>非公平锁。  两者的区别是说 可以看到和非公平策略相比，就多了一个对阻塞队列的检查。如果非公平， 直接参与竞争。线程A一点时间都没等待就和线程B同等对待。 </li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Semaphore sem = new Semaphore(1); </span><br><span class="line"></span><br><span class="line">sem.acquire(); </span><br><span class="line">sem.release();</span><br></pre></td></tr></table></figure>
<h4 id="栅栏-Barrier-CyclicBarrier"><a href="#栅栏-Barrier-CyclicBarrier" class="headerlink" title="栅栏 Barrier CyclicBarrier"></a>栅栏 Barrier CyclicBarrier</h4><p>循环栅栏：CyclicBarrier</p>
<p>想法就是等别的几个线程都执行完成了， 然后大家一起执行下面的工作。<br>和闭锁的区别呢： 就是等到这个点以后， 大家可以一起开始做什么事情。 而闭锁就是结束而已； 还有就是CyclicBarrier 是可以重用的， 而CountDownLatch 则是不能重用。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int N=4;</span><br><span class="line">CyclicBarrier barrier = new CyclicBarrier(N);</span><br><span class="line"></span><br><span class="line">for(int i=0; i&lt;N; i++)&#123;</span><br><span class="line">	new Writer(barrier).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static class Writer extends Thread&#123;</span><br><span class="line">	private CyclicBarrier cyclicBarrier;</span><br><span class="line">	public Writer(CyclicBarrier cyclicBarrier)&#123;</span><br><span class="line">		this.cyclicBarrier = cyclicBarrier;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void run()&#123;</span><br><span class="line">		System.out.println(Thread.currentThread().getName() + &quot; write data&quot;);</span><br><span class="line">		</span><br><span class="line">		try &#123;</span><br><span class="line">			Thread.sleep(2000);</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + &quot;write down, wait for else&quot;);</span><br><span class="line">			cyclicBarrier.await();</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			// TODO Auto-generated catch block</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; catch (BrokenBarrierException e) &#123;</span><br><span class="line">			// TODO Auto-generated catch block</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关于显示锁"><a href="#关于显示锁" class="headerlink" title="关于显示锁"></a>关于显示锁</h2><p>ReentrantLock 这个</p>
<p>–相对于synchronized 有些危险， 因为你如果没有release 会有问题。 </p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>感觉没有什么. </p>
<h2 id="java-内存模型"><a href="#java-内存模型" class="headerlink" title="java 内存模型"></a>java 内存模型</h2><ul>
<li>重排序： 就是说编译器根据自己的情况做一些优化。 底层实现看到了就收集一些吧。 </li>
<li>happen before 规则： JMM可以通过happens-before关系向程序员提供跨线程的内存可见性保证（如果A线程的写操作a与B线程的读操作b之间存在happens-before关系，尽管a操作和b操作在不同的线程中执行，但JMM向程序员保证a操作将对b操作可见）。</li>
</ul>
<p>JVM定义的Happens-Before原则是一组偏序关系：对于两个操作A和B，这两个操作可以在不同的线程中执行。如果A Happens-Before B，那么可以保证，当A操作执行完后，A操作的执行结果对B操作是可见的。</p>
<p>但是说A 不一定在B之前执行， 怎么理解 ？？？</p>
<h2 id="其他的ms-问题"><a href="#其他的ms-问题" class="headerlink" title="其他的ms 问题"></a>其他的ms 问题</h2><ul>
<li><p>什么叫fail-fast 。 就是如果进行操作， 直接抛出ConcurrentModificationException，</p>
</li>
<li><p>自旋锁， 可重入：<br>可重入是说当前线程获得锁之后呢， 还可以继续进入这个锁， 当然需要计数， release 的时候减少。 synchronize 和 reentonlock 的都是可以重入的。     不可重入呢， 就是不能再进去了。 自旋锁是说我去拿一个锁， 没有拿到， 然后呢， while 不断循环去拿这个锁。 信号量也是， ——》 这两个都是获得锁的方式。 java code 看不到因为是底层处理的。 但是自旋锁呢是在执行的 running 队列里面的， cpu 有了时间片就可以执行这个。   而Spin lock则不然，它属于busy-waiting类型的锁，如果线程A是使用pthread_spin_lock操作去请求锁，那么线程A就会一直在 Core0上进行忙等待并不停的进行锁请求，直到得到这个锁为止。- 多核cpu<br>而信号量则是放在waiting 队列里的。 这个要等待。 </p>
</li>
</ul>
<ul>
<li>线程的几种状态：New（新建状态），Runnable（就绪状态），Running（运行状态），Blocked（阻塞状态），Dead（死亡状态）。</li>
<li>wait/notify/notifyAll方法的作用是实现线程间的协作，那为什么这三个方法不是位于Thread类中，而是位于Object类中？位于Object中，也就相当于所有类都包含这三个方法（因为Java中所有的类都继承自Object类）。要回答这个问题，还是得回过来看wait方法的实现原理，大家需要明白的是，wait等待的到底是什么东西？如果对上面内容理解的比较好的话，我相信大家应该很容易知道wait等待其实是对象monitor，由于Java中的每一个对象都有一个内置的monitor对象，自然所有的类都理应有wait/notify方法。refer to <a href="http://www.cnblogs.com/paddix/p/5381958.html" target="_blank" rel="noopener">http://www.cnblogs.com/paddix/p/5381958.html</a></li>
</ul>
<h2 id="小结以及下一步"><a href="#小结以及下一步" class="headerlink" title="小结以及下一步"></a>小结以及下一步</h2><p>对多线程的基本场景和基本方式进行了一些了解。对整体的理解有了一些深入。 </p>
<p>为什么多线程会有安全问题， synchronized， lock， volatile的一些用法。 常用工具类的用法：futuretask, countdownlock, cylicbarrier, setaphone,<br>对线程池着墨不多。 </p>
<p>后期如有时间， 应该继续</p>
<ul>
<li>AQS 源码</li>
<li>lock 还需要继续深入以及实例。 </li>
</ul>
<p>Question</p>
<ul>
<li>偏向锁： synchronized 好像1.7 加了一些优化。 </li>
<li>wait sleep</li>
</ul>
<p>注意</p>
<ul>
<li>自己没有对cpu 指令层进行更多的学习， 觉得暂时必要性不大， 而且耗时较长。 以后有兴趣单独学习。 </li>
</ul>
<p>参考</p>
<ol>
<li>java 并发编程实战</li>
<li>并发专题 <a href="https://www.jianshu.com/p/27860941a77b" target="_blank" rel="noopener">https://www.jianshu.com/p/27860941a77b</a></li>
<li></li>
<li>镇楼<br><img src="C:/developer/blog/zyhnjust.github.io/source/_posts/java%E5%B9%B6%E5%8F%91%E6%A6%82%E8%BF%B0/2615789-0e32f116bae6062e.png" alt="总图"><br><img src="2615789-0e32f116bae6062e.png" alt="总图"></li>
<li>code  <a href="https://www.geeksforgeeks.org/countdownlatch-in-java/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/countdownlatch-in-java/</a></li>
<li></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/12/java并发概述/" data-id="cjmxges9a000b24tvbhn496l9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并发/">并发</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/09/14/同步异步，阻塞非阻塞/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          同步异步，阻塞非阻塞
        
      </div>
    </a>
  
  
    <a href="/2018/09/10/数据库常见问题/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">数据库常见问题</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AI/">AI</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/AI/ML/">ML</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/arch/">arch</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/arch/分布式/">分布式</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/network/">network</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/面试/">面试</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/面试/db/">db</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/面试/java/">java</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/面试/java/IO/">IO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/面试/java/JVM/">JVM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/面试/java/basic/">basic</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/面试/java/并发/">并发</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/面试/大数据/">大数据</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/面试/大数据/redis/">redis</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/面试/架构/">架构</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/面试/架构/微服务/">微服务</a></li></ul></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AI/">AI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IO/">IO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/arch/">arch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/db/">db</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jvm/">jvm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/microservice/">microservice</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vertx/">vertx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式事务/">分布式事务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/并发/">并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/面试/">面试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/AI/" style="font-size: 10px;">AI</a> <a href="/tags/IO/" style="font-size: 10px;">IO</a> <a href="/tags/arch/" style="font-size: 10px;">arch</a> <a href="/tags/db/" style="font-size: 10px;">db</a> <a href="/tags/http/" style="font-size: 10px;">http</a> <a href="/tags/java/" style="font-size: 20px;">java</a> <a href="/tags/jvm/" style="font-size: 10px;">jvm</a> <a href="/tags/microservice/" style="font-size: 10px;">microservice</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a> <a href="/tags/vertx/" style="font-size: 10px;">vertx</a> <a href="/tags/分布式事务/" style="font-size: 10px;">分布式事务</a> <a href="/tags/并发/" style="font-size: 10px;">并发</a> <a href="/tags/架构/" style="font-size: 10px;">架构</a> <a href="/tags/面试/" style="font-size: 20px;">面试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/10/05/关于机器学习流程以及几个度量的理解/">关于机器学习流程以及几个度量的理解</a>
          </li>
        
          <li>
            <a href="/2018/09/29/Http-time-wait状态/">Http_time_wait状态</a>
          </li>
        
          <li>
            <a href="/2018/09/29/二段式，三段式和Paxos/">二段式，三段式和Paxos</a>
          </li>
        
          <li>
            <a href="/2018/09/29/kubnetes-notes/">kubnetes_notes</a>
          </li>
        
          <li>
            <a href="/2018/09/28/分布式/">分布式</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 hzhang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="http://libs.baidu.com/jquery/2.1.1/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



<!-- 站内搜索-Swiftype -->
<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install','sC-iNFrvTTNtiXEVNwo1','2.0.0');
</script>
  </div>
</body>
</html>