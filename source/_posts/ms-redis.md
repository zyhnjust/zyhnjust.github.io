---
title: ms_meituan
date: 2018-09-09 14:24:18
tags:
- redis
- 面试
categories: 
- 面试
- 大数据
- redis
---

几道面试题目 - redis

<!-- more -->

# Redis
## 1. redis 介绍， 了解redis 集群么

A: redis是个开源的高性能的key value 的存储系统，基本特点
- - [ ] 1） 知此恨数据的持久化。 可以存到磁盘。 怎么存？ TODO
- 2） 除了key value 还有其他的数据结构， list set， topic 订阅的模式。 
- 3） 支持数据备份， master slave的数据备份 

优势 
- 1） 性能奥， 据说一秒 10万次左右。 写 8万次。 
- 2 数据类型丰富
- 3 原子操作， 单线程的。 
- 4 丰富的特性， 通知， key 过期等。 

内存调优： 
- 1） 不要开vm 选项。就是存储超过物理内存的再内存和磁盘幻如幻出的策略。 内存管理成本高。 
- 2） 可以设置redis。conf  maxmemory 这样一定内存后就可以拒绝了。 


内存淘汰策略：
1. noeviction：内存达到阈值， 所有申请内存的都会报错。 
1. allkeys-lru ， 优先移除最近没有使用的key
1. volatile-lru： 设置了过期时间的建空间 优先一处最近未使用的key
1. allkeys- random： 主键空间， 随机移除每个key
1. volatile-random： 再设置了过期实践的建空间中， 随机移除每个key。 
1. volatile-ttl 具有更早过期时间的先移除。 

## 1. Redis的持久化？有哪些方式，原理是什么？

持久化
- 1） RDB 快照就是默认的持久化方式。 基本思路是说用快照的方式写到二进制文件中， 默认 dump.rdb。- 可以redis 再多少key修改自动快照， 也可以命令行进行snapshotting。 
- 2） 基本的过程如下。 for 一个紫禁城。 父进程继续处理client 请求， 子进程把内存写入临时文件。由于os 写时复制机制 copy on write， 但是当如今成处理写的额时候 os 会给父进程要修改的页面创建一个副本，而不是共享的页面。 所以子进程的地址空间内的数据是for哪个时刻的数据的一个快照。 
-- 这个的不足就是因为两次快照有时间间隔， 那么如果数据库有了问题， 中间出现的改变就丢失了。 
- AOF 做持久化的时候呢， redis 将收到的每个写命令都通过write函数追加到文件中， 默认是 appendonly.aof， 重启的时候， 重新执行文件中的些命令再内存中重建整个数据库的内容。 当然os 还是现在内核中缓存这个修改， 而不是立即卸载磁盘上。 所以还是有可能丢失部分数据。 有几种情形是可以配置的： 
-  -  append only yes  启动持久化方式
-  - append fsync always 收到就立即强制写入， 最慢的选择， 不建议使用。 
-  - appendsync every sec 这个是比较推荐的
-  - appendsync no // 完全依赖os的处理， 这个持久化的时间就没有保证了， 但是性能是最好的。 
-  aof 带来另外的问题。就是文件太大， 比如调用incr test 100次， 文件要保存100次， 其实99次都是多余的。 所以为了压缩呢 redis 有 bgrewirteoof 命令。 收到之后呢， 将使用快照类似的方式将内存的数据以命令的方式保存到临时文件， 最后替换原来的文件。 -- 这个文件比原来的命令就小了很多。 
-  bgrewrite的执行过程
-  - redis 调用fork， 父子两个进程。 子进程根据内存的数据库快照， 往临时文件写入重建数据库状态的命令。 父进程继续处理client 请求， 除了把命令写入原来的aof， 还有缓存起来。 - 
-  - 子进程把快照内容写到临时文件中后， 子进程发信号通知父进程。 然后父进程把缓存的写命令也写入到临时文件。 这个时候父进程就可以用临时文件替换老的aof 文件， 并且重命名， 后面的命令就可以在新的aof 来追加。 
-  两种方式各有利弊。 快照对性能影响小， 崩溃了数据丢失较大。 aof 数据安全性较高， 性能影响较大。 

线程体系
- 基于单线程模型。 所以多个客户端对一个键进行写操作不会有并发问题。
- 除了客户请求之后有一些耗时操作， 如持久化RDB文件， 持久化AOF文件。 

主从复制
- [ ] 集群可能有很多的topic， 部署也有一些。  
- https://www.zhihu.com/question/21419897
- 目前我们只是用了三个节点以及三个哨兵的这种安装模式
- 
我们用了什么呢
- redis 做缓存， cmc 
- redis 做topic 订阅。 
- redis 做抢占


参考： https://www.jianshu.com/p/d9cf0c2f23bb

## redis memorycache

Redis最适合所有数据in-momory的场景，虽然Redis也提供持久化功能，但实际更多的是一个disk-backed的功能，跟传统意义上的持久化有比较大的差别，那么可能大家就会有疑问，似乎Redis更像一个加强版的Memcached，那么何时使用Memcached,何时使用Redis呢?

如果简单地比较Redis与Memcached的区别，大多数都会得到以下观点：
1. Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。
2. Redis支持数据的备份，即master-slave模式的数据备份。
3. Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用
4. redis相比memcached有哪些优势？ 　　
- 　　(1) memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型
- 　　(2) redis的速度比memcached快很多 
- 　　(3) redis可以持久化其数据
5. Memcache与Redis的区别都有哪些？    
- 存储方式 Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。 Redis有部份存在硬盘上，这样能保证数据的持久性。
- 数据支持类型 Memcache对数据类型支持相对简单。 Redis有复杂的数据类型。
- 使用底层模型不同 它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。 Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。


# 分布式缓存， 一致性Hash

- 可以用redis
- 数据结构(Data Structure)需求越来越多, 但memcache中没有, 影响开发效率
- 支持5种数据结构： 支持strings, hashes, lists, sets, sorted sets
- Redis使用单线程实现，Memcache等使用多线程实现，因此我们不推荐在Redis中存储太大的内容，否则会阻塞其它请求。
- 持久机制。 Redis提供了两种持久机制，包括RDB和AOF，前者是定时的持久机制，但在出现宕机时可能会出现数据丢失，后者是基于操作日志的持久机制。
- Redis官方推出了一个集群管理工具，叫作哨兵（Sentinel），负责在节点中选出主节点，按照分布式集群的管理办法来操作集群节点的上线、下线、监控、提醒、自动故障切换（主备切换），且实现了著名的RAFT选主协议，从而保证了系统选主的一致性。


refer
- https://dbaplus.cn/news-141-1988-1.html


# 架构： 一致性Hash
要回答这几个问题： 问题是什么， 解决办法， 为什么能解决， 优缺点， 其他。 

1. 在使用n台缓存服务器时，一种常用的负载均衡方式是，对资源o的请求使用 {\displaystyle {\mbox{hash}}(o)=o\mod n} {\mbox{hash}}(o)=o\mod n来映射到某一台缓存服务器。当增加或减少一台缓存服务器时这种方式可能会改变所有资源对应的hash值，也就是所有的缓存都失效了，这会使得缓存服务器大量集中地向原始内容服务器更新缓存。
2. 因此需要一致哈希算法来避免这样的问题。 一致哈希尽可能使同一个资源映射到同一台缓存服务器。这种方式要求增加一台缓存服务器时，新的服务器尽量分担存储其他所有服务器的缓存资源。减少一台缓存服务器时，其他所有服务器也可以尽量分担存储它的缓存资源。 一致哈希算法的主要思想是将每个缓存服务器与一个或多个哈希值域区间关联起来，其中区间边界通过计算缓存服务器对应的哈希值来决定。
3. 一致哈希将每个对象映射到圆环边上的一个点，系统再将可用的节点机器映射到圆环的不同位置。查找某个对象对应的机器时，需要用一致哈希算法计算得到对象对应圆环边上位置，沿着圆环边上查找直到遇到某个节点机器，这台机器即为对象应该保存的位置。
4. - 就是用一个圆环来实现这个东西。 
4. 几个特点
- 冗余少
- 负载均衡
- 过渡平滑
- 存储均衡
- 关键词单调




# 如何解决缓存的几个问题 缓存穿透， 缓存并发 缓存失效。 

几个问题
1. 缓存穿透

我们在项目中使用缓存通常都是先检查缓存中是否存在，如果存在直接返回缓存内容，如果不存在就直接查询数据库然后再缓存查询结果返回。这个时候如果我们查询的某一个数据在缓存中一直不存在，就会造成每一次请求都查询DB，这样缓存就失去了意义，在流量大时，可能DB就挂掉了。

要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。

如果是API 对外提供的， 确实有这个风险。 

如何解决： 
- 可以把这个不存在的key 设置一个值， 应用可以来决定是否等待。 还是放弃。 如果有值了， 就避免透传到数据库， 从而把大量请求挡在了缓存之中。 
- 实际上， 我们的业务场景不需要这样处理。 

2. 缓存并发
有时候如果网站并发访问高，一个缓存如果失效，可能出现多个进程同时查询DB，同时设置缓存的情况，如果并发确实很大，这也可能造成DB压力过大，还有缓存频繁更新的问题。

- 我现在的想法是对缓存查询加锁，如果KEY不存在，就加锁，然后查DB入缓存，然后解锁；其他进程如果发现有锁就等待，然后等解锁后返回数据或者进入DB查询。


3. 缓存失效
是说如果缓存在一段时间内一起失效， db的压力凸显。 
- 没有完美的解决办法， 尽量让失效点均匀分布， 
- 我们的业务暂时不需要。 

# 列举一个常用的redis 客户端的并发模型  - still todo

Redis 操作是原子的事实仅仅是单线程事件循环的结果。有趣的一点是, 原子性是以不额外的成本提供的 (它不需要同步)。用户可以利用它来实现乐观锁定和其他模式, 而无需支付同步开销。

- 可以自己管理锁吧。 还有别的想法么 

```
App 1             Redis              App 2
 |---- GET foo ---->|                  |
 |<------ 1 --------|<--- GET foo -----|
 |                  |------- 1 ------->|
 | thinking...      |                  |
 |                  |       thinking...|
 |--- SET foo 2 --->|                  |
 |<----- OK --------|<--- SET foo 2 ---|
 |                  |------ OK ------->|
```

# zk 功能  如何选举 

统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等工作


- 统一命名服务

统一命名服务
在分布式系统中，经常需要给一个资源生成一个唯一的ID，在没有中心管理结点的情况下生成这个ID并不是一件很容易的事儿。zk就提供了这样一个命名服务。

一般是使用create方法，创建一个自动编号的节点。

- 共享锁
- 队列管理
- 管理集群
- 

dubbo中采用zookeeper来作注册中心

HBase要用到zk，这个已经有答主提到，就不用细说了。Hadoop也是需要用到zookeeper的，用来管理集群中的NameNode。


