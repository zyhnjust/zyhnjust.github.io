---
title: ms_meituan
date: 2018-09-09 14:24:18
tags:
- redis
- 面试
categories: 
- 面试
- redis
---

几道面试题目 - redis

<!-- more -->

# Redis
## 1. redis 介绍， 了解redis 集群么

A: redis是个开源的高性能的key value 的存储系统，基本特点
- - [ ] 1） 知此恨数据的持久化。 可以存到磁盘。 怎么存？ TODO
- 2） 除了key value 还有其他的数据结构， list set， topic 订阅的模式。 
- 3） 支持数据备份， master slave的数据备份 

优势 
- 1） 性能奥， 据说一秒 10万次左右。 写 8万次。 
- 2 数据类型丰富
- 3 原子操作， 单线程的。 
- 4 丰富的特性， 通知， key 过期等。 

内存调优： 
- 1） 不要开vm 选项。就是存储超过物理内存的再内存和磁盘幻如幻出的策略。 内存管理成本高。 
- 2） 可以设置redis。conf  maxmemory 这样一定内存后就可以拒绝了。 


内存淘汰策略：
1. noeviction：内存达到阈值， 所有申请内存的都会报错。 
1. allkeys-lru ， 优先移除最近没有使用的key
1. volatile-lru： 设置了过期时间的建空间 优先一处最近未使用的key
1. allkeys- random： 主键空间， 随机移除每个key
1. volatile-random： 再设置了过期实践的建空间中， 随机移除每个key。 
1. volatile-ttl 具有更早过期时间的先移除。 

## 1. Redis的持久化？有哪些方式，原理是什么？

持久化
- 1） RDB 快照就是默认的持久化方式。 基本思路是说用快照的方式写到二进制文件中， 默认 dump.rdb。- 可以redis 再多少key修改自动快照， 也可以命令行进行snapshotting。 
- 2） 基本的过程如下。 for 一个紫禁城。 父进程继续处理client 请求， 子进程把内存写入临时文件。由于os 写时复制机制 copy on write， 但是当如今成处理写的额时候 os 会给父进程要修改的页面创建一个副本，而不是共享的页面。 所以子进程的地址空间内的数据是for哪个时刻的数据的一个快照。 
-- 这个的不足就是因为两次快照有时间间隔， 那么如果数据库有了问题， 中间出现的改变就丢失了。 
- AOF 做持久化的时候呢， redis 将收到的每个写命令都通过write函数追加到文件中， 默认是 appendonly.aof， 重启的时候， 重新执行文件中的些命令再内存中重建整个数据库的内容。 当然os 还是现在内核中缓存这个修改， 而不是立即卸载磁盘上。 所以还是有可能丢失部分数据。 有几种情形是可以配置的： 
-  -  append only yes  启动持久化方式
-  - append fsync always 收到就立即强制写入， 最慢的选择， 不建议使用。 
-  - appendsync every sec 这个是比较推荐的
-  - appendsync no // 完全依赖os的处理， 这个持久化的时间就没有保证了， 但是性能是最好的。 
-  aof 带来另外的问题。就是文件太大， 比如调用incr test 100次， 文件要保存100次， 其实99次都是多余的。 所以为了压缩呢 redis 有 bgrewirteoof 命令。 收到之后呢， 将使用快照类似的方式将内存的数据以命令的方式保存到临时文件， 最后替换原来的文件。 -- 这个文件比原来的命令就小了很多。 
-  bgrewrite的执行过程
-  - redis 调用fork， 父子两个进程。 子进程根据内存的数据库快照， 往临时文件写入重建数据库状态的命令。 父进程继续处理client 请求， 除了把命令写入原来的aof， 还有缓存起来。 - 
-  - 子进程把快照内容写到临时文件中后， 子进程发信号通知父进程。 然后父进程把缓存的写命令也写入到临时文件。 这个时候父进程就可以用临时文件替换老的aof 文件， 并且重命名， 后面的命令就可以在新的aof 来追加。 
-  两种方式各有利弊。 快照对性能影响小， 崩溃了数据丢失较大。 aof 数据安全性较高， 性能影响较大。 

线程体系
- 基于单线程模型。 所以多个客户端对一个键进行写操作不会有并发问题。
- 除了客户请求之后有一些耗时操作， 如持久化RDB文件， 持久化AOF文件。 

主从复制
- [ ] 集群可能有很多的topic， 部署也有一些。  
- https://www.zhihu.com/question/21419897
- 目前我们只是用了三个节点以及三个哨兵的这种安装模式
- 
我们用了什么呢
- redis 做缓存， cmc 
- redis 做topic 订阅。 
- redis 做抢占


参考： https://www.jianshu.com/p/d9cf0c2f23bb

## redis memorycache

Redis最适合所有数据in-momory的场景，虽然Redis也提供持久化功能，但实际更多的是一个disk-backed的功能，跟传统意义上的持久化有比较大的差别，那么可能大家就会有疑问，似乎Redis更像一个加强版的Memcached，那么何时使用Memcached,何时使用Redis呢?

如果简单地比较Redis与Memcached的区别，大多数都会得到以下观点：
1. Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。
2. Redis支持数据的备份，即master-slave模式的数据备份。
3. Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用
4. redis相比memcached有哪些优势？ 　　
- 　　(1) memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型
- 　　(2) redis的速度比memcached快很多 
- 　　(3) redis可以持久化其数据
5. Memcache与Redis的区别都有哪些？    
- 存储方式 Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。 Redis有部份存在硬盘上，这样能保证数据的持久性。
- 数据支持类型 Memcache对数据类型支持相对简单。 Redis有复杂的数据类型。
- 使用底层模型不同 它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。 Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。



ms 美团

# 美团题目整理 

<!-- more -->
# redis
1. redis 介绍， 了解redis 集群么
1. Redis的持久化？有哪些方式，原理是什么？

A: redis是个开源的高性能的key value 的存储系统，基本特点
- - [ ] 1） 知此恨数据的持久化。 可以存到磁盘。 怎么存？ TODO
- 2） 除了key value 还有其他的数据结构， list set， topic 订阅的模式。 
- 3） 支持数据备份， master slave的数据备份 

优势 
- 1） 性能奥， 据说一秒 10万次左右。 写 8万次。 
- 2 数据类型丰富
- 3 原子操作， 单线程的。 
- 4 丰富的特性， 通知， key 过期等。 

内存调优： 
- 1） 不要开vm 选项。就是存储超过物理内存的再内存和磁盘幻如幻出的策略。 内存管理成本高。 
- 2） 可以设置redis。conf  maxmemory 这样一定内存后就可以拒绝了。 


内存淘汰策略：
1. noeviction：内存达到阈值， 所有申请内存的都会报错。 
1. allkeys-lru ， 优先移除最近没有使用的key
1. volatile-lru： 设置了过期时间的建空间 优先一处最近未使用的key
1. allkeys- random： 主键空间， 随机移除每个key
1. volatile-random： 再设置了过期实践的建空间中， 随机移除每个key。 
1. volatile-ttl 具有更早过期时间的先移除。 

持久化
- 1） RDB 快照就是默认的持久化方式。 基本思路是说用快照的方式写到二进制文件中， 默认 dump.rdb。- 可以redis 再多少key修改自动快照， 也可以命令行进行snapshotting。 
- 2） 基本的过程如下。 for 一个紫禁城。 父进程继续处理client 请求， 子进程把内存写入临时文件。由于os 写时复制机制 copy on write， 但是当如今成处理写的额时候 os 会给父进程要修改的页面创建一个副本，而不是共享的页面。 所以子进程的地址空间内的数据是for哪个时刻的数据的一个快照。 
-- 这个的不足就是因为两次快照有时间间隔， 那么如果数据库有了问题， 中间出现的改变就丢失了。 
- AOF 做持久化的时候呢， redis 将收到的每个写命令都通过write函数追加到文件中， 默认是 appendonly.aof， 重启的时候， 重新执行文件中的些命令再内存中重建整个数据库的内容。 当然os 还是现在内核中缓存这个修改， 而不是立即卸载磁盘上。 所以还是有可能丢失部分数据。 有几种情形是可以配置的： 
-  -  append only yes  启动持久化方式
-  - append fsync always 收到就立即强制写入， 最慢的选择， 不建议使用。 
-  - appendsync every sec 这个是比较推荐的
-  - appendsync no // 完全依赖os的处理， 这个持久化的时间就没有保证了， 但是性能是最好的。 
-  aof 带来另外的问题。就是文件太大， 比如调用incr test 100次， 文件要保存100次， 其实99次都是多余的。 所以为了压缩呢 redis 有 bgrewirteoof 命令。 收到之后呢， 将使用快照类似的方式将内存的数据以命令的方式保存到临时文件， 最后替换原来的文件。 -- 这个文件比原来的命令就小了很多。 
-  bgrewrite的执行过程
-  - redis 调用fork， 父子两个进程。 子进程根据内存的数据库快照， 往临时文件写入重建数据库状态的命令。 父进程继续处理client 请求， 除了把命令写入原来的aof， 还有缓存起来。 - 
-  - 子进程把快照内容写到临时文件中后， 子进程发信号通知父进程。 然后父进程把缓存的写命令也写入到临时文件。 这个时候父进程就可以用临时文件替换老的aof 文件， 并且重命名， 后面的命令就可以在新的aof 来追加。 
-  两种方式各有利弊。 快照对性能影响小， 崩溃了数据丢失较大。 aof 数据安全性较高， 性能影响较大。 

线程体系
- 基于单线程模型。 所以多个客户端对一个键进行写操作不会有并发问题。
- 除了客户请求之后有一些耗时操作， 如持久化RDB文件， 持久化AOF文件。 

主从复制
- 


我们用了什么呢
- redis 做缓存， cmc 
- redis 做topic 订阅。 
- redis 做抢占


参考： https://www.jianshu.com/p/d9cf0c2f23bb

- collection
- - B+树和B-树的区别
- - ConcurrentHashMap1.8源码解析

- - 7.hashmap和concurrenthashmap的size方法怎么实现的
- -  hashmap 原理， 增删情况， 后端数据结构如何位移
- - hashmap的容量为什么是2 的幂次
- - hashset 的源码
- java
- - hashcode equals， 你重写过么， 需要注意什么
- - 注解用过么， 
- - 动态代理的实现方式和区别
- 算法 
-  - 讲一下稳定的排序算法和不稳定的排序算法
-  - 讲一下快速排序的思想
- - leeetcode原题 22，Generate Parentheses，给定 n 对括号，请写一个函数以将其生成新的括号组合，并返回所有组合结果。
- 
- 数据库
- -  讲一下数据的acid
- - 什么是一致性
- - 什么是隔离性
- - Mysql的隔离级别
- - 每个隔离级别是如何解决
- - Mysql要加上nextkey锁，语句该怎么写
- - 10.mysql死锁，怎么解决，如果不要求执行顺序，死锁怎么解决
复合索引
聚集索引和非聚集索引的区别？
数据库索引 主键和唯一索引有什么区别
索引失效条件，什么时候该建立索引
innDB和MyISAM的区别？
- - 数据库的索引原理
非聚簇索引和聚簇索引
索引的使用注意事项
联合索引
Mysql对联合索引有优化么？会自动调整顺序么？哪个版本开始优化？

- java jvm
- - Java的内存模型，垃圾回收
- - 5.通过反射，谈到了方法区，然后，类加载机制？
- - 8.JVM的调优参数？（-Xmn，-Xms等具体参数设置）

- wangluo 
- - 13.TCP三次握手，为什么三次握手？

- misc
- - 如何设计单点登录，单点登录的原理

- 线程并发
- - 线程池的参数
- - 6.synchronized的实现原理？Volatile能保证原子性吗？为什么？
- - 线程池优点，参数，如果我想实现newSingleThreadPoll，应该怎么配置，构造方法传什么参数
- - 12.线程的五态？转化过程？
- - reentrantlock的实现
- -线程池的设计
线程池如何做负载均衡
如何实现线程调度算法

- NIO
- - Nio和IO有什么区别
- - Nio和aio的区别

- spring
- - Spring的aop怎么实现
- - Spring的aop有哪些实现方式
- - 3.Spring的bean的作用域？（比如：singleton，prototype等）
- - Spring的IOC实现原理？没有无参构造函数能实例化吗？有参构造函数注入？（xml配置）


- linxu
- - 如何查找目录下的大文件

```
du : 计算出单个文件或者文件夹的磁盘空间占用.
sort : 对文件行或者标准输出行记录排序后输出.
head : 输出文件内容的前面部分.
      用下面的命令组合就可以完成上述查找工作：

      

# du -a /var | sort -n -r | head -n 10
      如果需要输出可读性高的内容，请使用如下命令：

$ cd /path/to/some/where
$ du -hsx * | sort -rh | head -10
```

