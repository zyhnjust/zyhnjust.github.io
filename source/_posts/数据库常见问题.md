---
title: 数据库常见问题
date: 2018-09-10 11:06:34
tags: db
categories: 
- 面试
- db
---

update 2018-09-18 mysql some

DB 
数据库领域的一些常见问题。 不求全， 添加中。 耗时的可以列在TODO
- 希望是自己的理解， 

<!-- more -->
# 问题列表
- 讲一下数据的ACID，一致性， 隔离性， 
- 索引的问题， 索引原理； 
- 非聚簇索引和聚簇索引
 索引的使用注意事项
 联合索引
- innodb myisam 区别
- B+ B tree 区别
- 说一说三个范式。

- MYSQL sql 的基本思路 - - 左连接 有链接
- 如何优化， 这个太大了。 
- 简单说一说drop、delete与truncate的区别
- mysql的问题
- 什么是存储过程？有哪些优缺点？
- 数据库的乐观锁和悲观锁是什么？
- 分库分表

- 基本思路， 我们用了 postgres， 也有mysql， redshift。 做过一些调优。 

# 计划做的。 
1. 工作中用到的先聊一下呢。 
2. 尤其是那些报表， CMC 理解
2. 关于数据库基本原理的一些题目
3. 隔离级别等还是比较重要的 
4. 0. CMC 的报表怎么说。 
1. 是想看一些aws， redshift 有什么重要特性， 然后列个点。 希望弄多深入是不可能的
4. 关于mysql的一些基本问题。 innodb myisam 区别
5. B+ B tree 原理了解一下。 

# 关于事务
事务： 就是一个操作序列， 要么都执行， 要么都不执行， 如果执行一部分失败， 需要回退到最初的状态。 

# ACID 
首先ACID 是说一个事务的几个特点 
- Atomicity原子性
- consistency 一致性
- Isolation 隔离性
- Durability 耐久性

1. 原子性是说这件事情要么都发生要么不发生。 
比如这个事务包含几个操作， 如果中间失败了， 那么要支持回滚， 这就是原子性
2. 一致性。 一般来解释是说比如银行账户一共1万块两个人， 如果一个人转给第二个人100， 那么转出和转入比如同时， 就是总值一直是一致的。 是不是说两者就在一个事务中。 
3. 隔离性。 这个操作过程中的状态， 其他的操作是不可见的。 ？ 
有几种隔离级别， 后面讨论。 
4. 耐久性。 - 持久性
就是说事务完成之后， 所做的改动将会永久保存下来而不会回滚， 指的是改动会保存硬盘之中。 


# 隔离级别 （ 脏读不可重复读幻读）

隔离级别 | 脏读 | 不可重复读 | 幻读
---|--- |--- |---
未提交读 | 是 | 是 | 是 
已提交读 | 否 | 是 | 是
可重复读 | 否 | 否 | 是
可串行读 | 否 | 否 | 否

- 脏读：事务1做了操作， 改了一个数据， 但是没有提交。 事务2读取到了这个数据， 然后认为已经修改了。 但是事务1会滚了。 这样事务2 就是脏读。 
- 不可重复读： 就是说一个事务中同一查询两次返回了不同的结果。 因为在中间有另外一个事务提交了修改。 
- 幻读： 比如第一个事务对一个表的所有数据进行了修改， 同时第二个事务也修改这个表， 比如添加了一行， 就会发现第一个事物的用户表发现还没有修改的行。 就像幻觉一样。 
- - 这个发生是说没有对整个表加锁。 这样添加行就不会被禁止。 
- 丢失更新： 两个事务同时读取同一条记录。 A 先修改， B也修改，B提交之后覆盖了A的修改。 

- 未提交读： 在读数据的时候不会检查或者使用任何锁， 因此， 这种隔离中可能读到没有提交的结果。 就是说可能脏读。 
- 已提交读： 只读取提交的数据。 读数据的共享锁在读操作后立即释放。 SQL server 默认这个
- - 因为读了就释放共享锁， 所以再读可能是不同的， 也就是说是不可重复读。 
- 可重复读： 和已提交读类似的读数据， 但是直到事务结束才释放共享锁。 
- 可串行读： 工作方式类似可重复读。 但是不仅锁定受影响的数据， 还会锁定这个范围。 这样就阻止了新数据查询所涉及的范围。 


# 范式
有迹可循的有 八个。 常用的是前三个范式， 每个要求依次递加。 第一范式， 第二范式， 第三范式。 
- 第一范式。 强调的是列的原子性， 就是说列不能再分成其它几列。 
- 第二范式。 一是表必须有一个主键， 而是没有包含在主键中的列必须完全依赖于主键。 
- 第三范式。 在1NF基础上，任何非主属性不依赖于其它非主属性[在2NF基础上消除传递依赖]。

REfer：https://blog.csdn.net/Dream_angel_Z/article/details/45175621

# 数据库索引以及相关理解 - 

- 数据库索引的实现原理
索引的原理， 数据库索引是数据库管理中的一个排序的数据结构， 以吸住快速查询， 更新数据库中的数据。 实现通常用的是B树以及变种B+树。 当然， 数据之外， 数据库系统还维护着满足特定查找算法的数据结构， 这些数据结构以某种方式引用或者指向数据。 这种数据结构就是索引。 

创建索引， 可以大大提高系统的查询速度。 

设置索引的代价： 1） 增加了数据库的存储空间， 2） 在插入和修改数据的时候要花费较多的时间 3）创建和维护索引页需要耗费时间。 


```
常用的需要设置索引的建议：
- 经常需要搜索的列上， 可以加快搜索的速度。 
- 在作为主键的列上， 
- 在经常用在连接的列上， 主要是一些外键， 可以加快速度。 
- 在经常要根据范围进行搜索的裂伤， 因为索引已经排序了， 制定的范围是连续的。 
- 在经常需要排序的列上创建索引， 
- 在经常使用在where 子句的列上创建索引， 加快条件的判断速度。 

不需要设置索引的建议：
- 那些查询中很少使用， 或者参考的列。 
- 只有很少数据值的列。 比如性别
- 类型为text image， bit等
- 修改性能远大于检索性能。 - 因为这两者是相对的。
```

- mysql中普遍使用B+Tree做索引，但在实现上又根据聚簇索引和非聚簇索引而不同。
聚簇索引是对磁盘上实际数据重新组织以按指定的一个或多个列的值排序的算法。特点是存储数据的顺序和索引顺序一致。
一般情况下主键会默认创建聚簇索引，且一张表只允许存在一个聚簇索引。

在《数据库原理》一书中是这么解释聚簇索引和非聚簇索引的区别的：
聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。

- B树的基本理解， B+ 树
一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。

B-Tree：如果一次检索需要访问4个节点，数据库系统设计者利用磁盘预读原理，把节点的大小设计为一个页，那读取一个节点只需要一次I/O操作，完成这次检索操作，最多需要3次I/O(根节点常驻内存)。数据记录越小，每个节点存放的数据就越多，树的高度也就越小，I/O操作就少了，检索效率也就上去了。

B 树的要求
![](D:/developer/blog/zyhnjust.github.io/source/_posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/123.gif)
![](123.gif)

B+Tree：非叶子节点只存key，大大滴减少了非叶子节点的大小，那么每个节点就可以存放更多的记录，树更矮了，I/O操作更少了。所以B+Tree拥有更好的性能。

区别：一棵m阶的B+树和m阶的B树的异同点在于：

      1.有n棵子树的结点中含有n-1 个关键字； (此处颇有争议，B+树到底是与B 树n棵子树有n-1个关键字 保持一致，还是不一致：B树n棵子树的结点中含有n个关键字，待后续查证。暂先提供两个参考链接：①wikipedia http://en.wikipedia.org/wiki/B%2B_tree#Overview；②http://hedengcheng.com/?p=525。而下面B+树的图尚未最终确定是否有问题，请读者注意)

      2.所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。 (而B 树的叶子节点并没有包括全部需要查找的信息)

      3.所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B 树的非终节点也包含需要查找的有效信息)  B+ 这里非终端只有索引， 这样读写代价低

然后还有， 
1. B+-tree的磁盘读写代价更低 
B+-tree的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了
2. B+-tree的查询效率更加稳定
由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

- 红黑树

```
因为一棵由n个结点随机构造的二叉查找树的高度为lgn，所以顺理成章，二叉查找树的一般操作的执行时间为O(lgn)。但二叉查找树若退化成了一棵具有n个结点的线性链后，则这些操作最坏情况运行时间为O(n)。

红黑树虽然本质上是一棵二叉查找树，但它在二叉查找树的基础上增加了着色和相关的性质使得红黑树相对平衡，从而保证了红黑树的查找、插入、删除的时间复杂度最坏为O(log n)。

但它是如何保证一棵n个结点的红黑树的高度始终保持在logn的呢？这就引出了红黑树的5个性质：

每个结点要么是红的要么是黑的。  
根结点是黑的。  
每个叶结点（叶结点即指树尾端NIL指针或NULL结点）都是黑的。  
如果一个结点是红的，那么它的两个儿子都是黑的。  
 对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点。
```

- - 用在treemap里面 不错的性能。 如果读collection 的话就会有收获。 
需要知道红黑树是

# MyisAM索引与InnoDB索引相比较 （转）

- 只能是从参考材料了解一下。 后期如果使用可以更实际的体会。 如何使用， 如何实现的。 

## 总体介绍 
MYISAM 强调的是性能， 执行速度别InnoDB更快， 但是不提供事务支持。 
而InnoDB提供事务支持以及外键等高级数据库功能。 
InnoDB支持行级锁。 

历史

MySQL也导入了InnoDB（另一种数据库引擎），以强化参考完整性与并发违规处理机制，后来就逐渐取代MyISAM。
MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的，如果你不知道用什么，那就用InnoDB，至少不会差。
## 区别 

1. InnoDB支持事务，MyisAM不支持
2. InnoDB 中不保存表的具体行数，也就是说，执行select count(*) from table时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count(*)语句包含 where条件时，两种表的操作是一样的。
3. MyisAM键值分离，索引载入内存（key_buffer_size），数据缓存依赖操作系统；InnoDB键值一起保存，索引与数据一起载入InnoDB缓冲池；MyisAM主键（唯一）索引按升序来存储存储，InnoDB则不一定
MyisAM索引的基数值（Cardinality，show index
4. 表锁MYISAM, 提供行锁(locking on row level)，提供与 Oracle 类型一致的不加锁读取(non-locking read in
   SELECTs)，另外，InnoDB表的行锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表， 例如update table set num=1 where name like “%aaa%”
5. InnoDB不支持FULLTEXT类型的索引。现在新版本好像支持了。 全文索引， 就是这种类型的索引支持。 


## 选择
1. 是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；
2. 如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读写也挺频繁，请使用InnoDB。如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表
3. 没啥特殊的话请使用innodb。 myisam已被放弃。
4. 如果数据表涉及的存储数据多、查询多，用myisam，如文章表。读操作多用MyISAM， 
5. 写操作多用InnoDB, 如果数据表涉及业务逻辑多，增删改操作多，就用innodb，如订单表。

## 其他

作为使用MySQL的用户角度出发，Innodb和MyISAM都是比较喜欢的，如果数据库平台要达到需求：99.9%的稳定性，方便的扩展性和高可用性来说的话，MyISAM绝对是首选。
原因如下：
　　1、平台上承载的大部分项目是读多写少的项目，而MyISAM的读性能是比Innodb强不少的。
　　2、MyISAM的索引和数据是分开的，并且索引是有压缩的，内存使用率就对应提高了不少。能加载更多索引，而Innodb是索引和数据是紧密捆绑的，没有使用压缩从而会造成Innodb比MyISAM体积庞大不小。


# 数据库的乐观锁和悲观锁是什么？
我的理解呢， 乐观锁就是默认这个锁是可以获得的， 就去更新， 如果发现失败， 再尝试。 
悲观锁， 默认是拿不到的， 那么就先去取。 取不到就不做事情。 举例呢， 乐观锁是

## 理解
这是并发控制的两种方法。 

### 悲观锁
假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。

```
在关系数据库管理系统里，悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）是一种并发控制的方法。它可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事务执行的操作都某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。
悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。
```


实现 

往往依靠数据库提供的锁机制。 自己去锁也可以， 但是不能保证别的应用不会去更改。 

流程

对任意记录修改之前， 先加上一个排他锁， 如果加锁失败， 说明记录正在被修改。 如果加锁成功， 就可以具体修改。 其他的操作都会等待我们解锁， 或者直接抛出异常。 

理解

处理锁， 会让数据库产生额外的开销。 

实例

Java synchronized 就属于悲观锁的一种实现，每次线程要修改数据时都先获得锁，保证同一时刻只有一个线程能操作数据，其他线程则会被block。


### 乐观锁
顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。乐观锁适用于读多写少的应用场景，这样可以提高吞吐量。


```
在关系数据库管理系统里，乐观并发控制（又名“乐观锁”，Optimistic Concurrency Control，缩写“OCC”）是一种并发控制的方法。它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。乐观事务控制最早是由孔祥重（H.T.Kung）教授提出。

```

实现

两种方式， 使用版本号， 使用时间戳。 

何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。

CAS

CAS的全称是Compare and Swap，即比较并交换。比较的是当前内存中存储的值与预期原值，交换的是新值与内存中的值。这个操作是硬件层面的指令，因此能够保证原子性。Java通过JNI（本地方法调用）来使用这个原子操作，也是乐观锁最常用的机制。
CAS操作包含三个操作数——内存位置、预期原值和新值。在执行CAS操作时，先进行Compare操作，即比较内存位置的值与预期原值是否相等，若相等，则执行Swap操作将新值放入该内存位置。若不相等，则不进行Swap操作。

理解 --》预期原值， 新值是依赖于旧值的。 这个线程得到了一个新值， 然后不知道其他是否已经修改， 可以比较预期原值和现在内存是否一致。 如果相同， 就是说没人改过。 如果改了， 就需要重新执行循环， 就是从内存更新原值， 更新， 再去CAS。 


使用时间戳（timestamp）。乐观锁定的第二种实现方式和第一种差不多，同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）, 和上面的version类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。

实例

Java JUC中的atomic包就是乐观锁的一种实现，AtomicInteger 通过CAS（Compare And Set）操作实现线程安全的自增。

# MYSQL 主从复制的基本原理。 

想理解这个问题， 我觉得需要知道MYSQL的集群模式是如何的。 

Mysql 的复制是一个异步的复制。 （mysql 5.1.7 以上为异步和半同步两种）从master 到slave。 
三个线程来做， 两个在SLave， 就是SQL 和IO 县城， 另外一个IO在master。 

- 打开master的binary long 功能。 就是根据这个日志在slave再执行一下。 

过程

- 2.1．Slave 上面的IO线程连接上 Master，并请求从指定日志文件的指定位置(或者从最开始的日志)之后的日志内容；
- 2.2. Master 接收到来自 Slave 的 IO 线程的请求后，通过负责复制的 IO 线程根据请求信息读取指定日志指定位置之后的日志信息，返回给 Slave 端的 IO 线程。返回信息中除了日志所包含的信息之外，还包括本次返回的信息在 Master 端的 Binary Log 文件的名称以及在 Binary Log 中的位置；
- 2.3. Slave 的 IO 线程接收到信息后，将接收到的日志内容依次写入到 Slave 端的Relay Log文件(mysql-relay-bin.xxxxxx)的最末端，并将读取到的Master端的bin-log的文件名和位置记录到master- info文件中，以便在下一次读取的时候能够清楚的高速Master“我需要从某个bin-log的哪个位置开始往后的日志内容，请发给我”
- 2.4. Slave 的 SQL 线程检测到 Relay Log 中新增加了内容后，会马上解析该 Log 文件中的内容成为在 Master 端真实执行时候的那些可执行的 Query 语句，并在自身执行这些 Query。这样，实际上就是在 Master 端和 Slave 端执行了同样的 Query，所以两端的数据是完全一样的。

三种模式 

3.1.从 MySQL 5.1.12 开始，可以用以下三种模式来实现：
– 基于SQL语句的复制(statement-based replication, SBR)，SBR 模式是默认的。
– 基于行的复制(row-based replication, RBR)，
– 混合模式复制(mixed-based replication, MBR)。


## 优缺点
MySQL的主从同步是一个很成熟的架构，优点为：①在从服务器可以执行查询工作(即我们常说的读功能)，降低主服 务器压力;②在从主服务器进行备份，避免备份期间影响主服务器服务;③当主服务器出现问题时，可以切换到从服务器。所以我在项目部署和实施中经常会采用这种方案;鉴于生产环境下的mysql的严谨性。

在MySQL5.5版本中，引入了半同步复制模式（Semi-synchronous Replication）能够成功（只是相对的）避免上述数据丢失的隐患。在这种模式下：master会等到binlog成功传送并写入至少一个slave的relay log之后才会提交，否则一直等待，直到timeout（默认10s）。当出现timeout的时候，master会自动切换半同步为异步，直到至少有一个slave成功收到并发送Acknowledge，master会再切换回半同步模式。结合这个新功能，我们可以做到，在允许损失一定的事务吞吐量的前提下来保证同步数据的绝对安全，因为当你设置timeout为一个足够大的值的情况下，任何提交的数据都会安全抵达slave。


# Other TODO
TODO： 一般的集群模式， 


TODO List - 先给出基本的理解， 后面有时间再深入。 
1. B树， 这个还是比较复杂的如果想弄的比较清楚的话。 参考 https://blog.csdn.net/v_JULY_v/article/details/6530142/
2. 红黑树 https://blog.csdn.net/v_JULY_v/article/details/6105630
3. https://blog.csdn.net/hxpjava1/article/details/55803923 索引原理
4. https://www.cnblogs.com/shijianchuzhenzhi/p/6666537.html 索引比较


link
- https://blog.csdn.net/gui951753/article/details/79489279
- http://blog.csdn.net/weiliangliang111/article/details/51333169  - 索引
- https://segmentfault.com/a/1190000008227211   MyISAM
- https://www.zhihu.com/question/20596402   MyISAM
- http://www.hollischuang.com/archives/934 悲观锁
- https://www.jianshu.com/p/f5ff017db62a 
- https://blog.csdn.net/L_BestCoder/article/details/79304206  CAS
- http://blog.51cto.com/wangwei007/965575 mysql 复制 todo
- 


