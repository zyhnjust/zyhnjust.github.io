---
title: 数据库常见问题
date: 2018-09-10 11:06:34
tags: db
category: db
---

DB 
数据库领域的一些常见问题。 不求全， 添加中。 耗时的可以列在TODO
- 希望是自己的理解， 

<!-- more -->
# 问题列表
- 讲一下数据的ACID，一致性， 隔离性， 
- 索引的问题， 索引原理； 
- 非聚簇索引和聚簇索引
 索引的使用注意事项
 联合索引
- innodb myisam 区别
- B+ B tree 区别
- 说一说三个范式。

- MYSQL sql 的基本思路 - - 左连接 有链接
- 如何优化， 这个太大了。 
- 简单说一说drop、delete与truncate的区别
- mysql的问题
- 什么是存储过程？有哪些优缺点？
- 数据库的乐观锁和悲观锁是什么？
- 分库分表

- 基本思路， 我们用了 postgres， 也有mysql， redshift。 做过一些调优。 

# 计划做的。 
1. 工作中用到的先聊一下呢。 
2. 尤其是那些报表， CMC 理解
2. 关于数据库基本原理的一些题目
3. 隔离级别等还是比较重要的 
4. 0. CMC 的报表怎么说。 
1. 是想看一些aws， redshift 有什么重要特性， 然后列个点。 希望弄多深入是不可能的
4. 关于mysql的一些基本问题。 innodb myisam 区别
5. B+ B tree 原理了解一下。 

# 关于事务
事务： 就是一个操作序列， 要么都执行， 要么都不执行， 如果执行一部分失败， 需要回退到最初的状态。 

# ACID 
首先ACID 是说一个事务的几个特点 
- Atomicity原子性
- consistency 一致性
- Isolation 隔离性
- Durability 耐久性

1. 原子性是说这件事情要么都发生要么不发生。 
比如这个事务包含几个操作， 如果中间失败了， 那么要支持回滚， 这就是原子性
2. 一致性。 一般来解释是说比如银行账户一共1万块两个人， 如果一个人转给第二个人100， 那么转出和转入比如同时， 就是总值一直是一致的。 是不是说两者就在一个事务中。 
3. 隔离性。 这个操作过程中的状态， 其他的操作是不可见的。 ？ 
有几种隔离级别， 后面讨论。 
4. 耐久性。 - 持久性
就是说事务完成之后， 所做的改动将会永久保存下来而不会回滚， 指的是改动会保存硬盘之中。 


# 隔离级别 （ 脏读不可重复读幻读）

隔离级别 | 脏读 | 不可重复读 | 幻读
---|--- |--- |---
未提交读 | 是 | 是 | 是 
已提交读 | 否 | 是 | 是
可重复读 | 否 | 否 | 是
可串行读 | 否 | 否 | 否

- 脏读：事务1做了操作， 改了一个数据， 但是没有提交。 事务2读取到了这个数据， 然后认为已经修改了。 但是事务1会滚了。 这样事务2 就是脏读。 
- 不可重复读： 就是说一个事务中同一查询两次返回了不同的结果。 因为在中间有另外一个事务提交了修改。 
- 幻读： 比如第一个事务对一个表的所有数据进行了修改， 同时第二个事务也修改这个表， 比如添加了一行， 就会发现第一个事物的用户表发现还没有修改的行。 就像幻觉一样。 
- - 这个发生是说没有对整个表加锁。 这样添加行就不会被禁止。 
- 丢失更新： 两个事务同时读取同一条记录。 A 先修改， B也修改，B提交之后覆盖了A的修改。 

- 未提交读： 在读数据的时候不会检查或者使用任何锁， 因此， 这种隔离中可能读到没有提交的结果。 就是说可能脏读。 
- 已提交读： 只读取提交的数据。 读数据的共享锁在读操作后立即释放。 SQL server 默认这个
- - 因为读了就释放共享锁， 所以再读可能是不同的， 也就是说是不可重复读。 
- 可重复读： 和已提交读类似的读数据， 但是直到事务结束才释放共享锁。 
- 可串行读： 工作方式类似可重复读。 但是不仅锁定受影响的数据， 还会锁定这个范围。 这样就阻止了新数据查询所涉及的范围。 


# 范式
有迹可循的有 八个。 常用的是前三个范式， 每个要求依次递加。 第一范式， 第二范式， 第三范式。 
- 第一范式。 强调的是列的原子性， 就是说列不能再分成其它几列。 
- 第二范式。 一是表必须有一个主键， 而是没有包含在主键中的列必须完全依赖于主键。 
- 第三范式。 在1NF基础上，任何非主属性不依赖于其它非主属性[在2NF基础上消除传递依赖]。

REfer：https://blog.csdn.net/Dream_angel_Z/article/details/45175621

# 数据库索引以及相关理解 - 

- 数据库索引的实现原理
索引的原理， 数据库索引是数据库管理中的一个排序的数据结构， 以吸住快速查询， 更新数据库中的数据。 实现通常用的是B树以及变种B+树。 当然， 数据之外， 数据库系统还维护着满足特定查找算法的数据结构， 这些数据结构以某种方式引用或者指向数据。 这种数据结构就是索引。 

创建索引， 可以大大提高系统的查询速度。 

设置索引的代价： 1） 增加了数据库的存储空间， 2） 在插入和修改数据的时候要花费较多的时间 3）创建和维护索引页需要耗费时间。 


```
常用的需要设置索引的建议：
- 经常需要搜索的列上， 可以加快搜索的速度。 
- 在作为主键的列上， 
- 在经常用在连接的列上， 主要是一些外键， 可以加快速度。 
- 在经常要根据范围进行搜索的裂伤， 因为索引已经排序了， 制定的范围是连续的。 
- 在经常需要排序的列上创建索引， 
- 在经常使用在where 子句的列上创建索引， 加快条件的判断速度。 

不需要设置索引的建议：
- 那些查询中很少使用， 或者参考的列。 
- 只有很少数据值的列。 比如性别
- 类型为text image， bit等
- 修改性能远大于检索性能。 - 因为这两者是相对的。
```

- mysql中普遍使用B+Tree做索引，但在实现上又根据聚簇索引和非聚簇索引而不同。
聚簇索引是对磁盘上实际数据重新组织以按指定的一个或多个列的值排序的算法。特点是存储数据的顺序和索引顺序一致。
一般情况下主键会默认创建聚簇索引，且一张表只允许存在一个聚簇索引。

在《数据库原理》一书中是这么解释聚簇索引和非聚簇索引的区别的：
聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。

- B树的基本理解， B+ 树
一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。

B-Tree：如果一次检索需要访问4个节点，数据库系统设计者利用磁盘预读原理，把节点的大小设计为一个页，那读取一个节点只需要一次I/O操作，完成这次检索操作，最多需要3次I/O(根节点常驻内存)。数据记录越小，每个节点存放的数据就越多，树的高度也就越小，I/O操作就少了，检索效率也就上去了。

B 树的要求
![](C:/developer/blog/zyhnjust.github.io/source/_posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/123.gif)
![](123.gif)

B+Tree：非叶子节点只存key，大大滴减少了非叶子节点的大小，那么每个节点就可以存放更多的记录，树更矮了，I/O操作更少了。所以B+Tree拥有更好的性能。

区别：一棵m阶的B+树和m阶的B树的异同点在于：

      1.有n棵子树的结点中含有n-1 个关键字； (此处颇有争议，B+树到底是与B 树n棵子树有n-1个关键字 保持一致，还是不一致：B树n棵子树的结点中含有n个关键字，待后续查证。暂先提供两个参考链接：①wikipedia http://en.wikipedia.org/wiki/B%2B_tree#Overview；②http://hedengcheng.com/?p=525。而下面B+树的图尚未最终确定是否有问题，请读者注意)

      2.所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。 (而B 树的叶子节点并没有包括全部需要查找的信息)

      3.所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B 树的非终节点也包含需要查找的有效信息)  B+ 这里非终端只有索引， 这样读写代价低

然后还有， 
1. B+-tree的磁盘读写代价更低 
B+-tree的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了
2. B+-tree的查询效率更加稳定
由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

- 红黑树

```
因为一棵由n个结点随机构造的二叉查找树的高度为lgn，所以顺理成章，二叉查找树的一般操作的执行时间为O(lgn)。但二叉查找树若退化成了一棵具有n个结点的线性链后，则这些操作最坏情况运行时间为O(n)。

红黑树虽然本质上是一棵二叉查找树，但它在二叉查找树的基础上增加了着色和相关的性质使得红黑树相对平衡，从而保证了红黑树的查找、插入、删除的时间复杂度最坏为O(log n)。

但它是如何保证一棵n个结点的红黑树的高度始终保持在logn的呢？这就引出了红黑树的5个性质：

每个结点要么是红的要么是黑的。  
根结点是黑的。  
每个叶结点（叶结点即指树尾端NIL指针或NULL结点）都是黑的。  
如果一个结点是红的，那么它的两个儿子都是黑的。  
 对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点。
```

- - 用在treemap里面 不错的性能。 如果读collection 的话就会有收获。 
需要知道红黑树是

- MyisAM索引与InnoDB索引相比较 （转）


```
MyisAM支持全文索引（FULLTEXT）、压缩索引，InnoDB不支持；
++InnoDB支持事务，MyisAM不支持；++
MyisAM顺序储存数据，索引叶子节点保存对应数据行地址，辅助索引很主键索引相差无几；InnoDB主键节点同时保存数据行，其他辅助索引保存的是主键索引的值；
MyisAM键值分离，索引载入内存（key_buffer_size），数据缓存依赖操作系统；InnoDB键值一起保存，索引与数据一起载入InnoDB缓冲池；MyisAM主键（唯一）索引按升序来存储存储，InnoDB则不一定
MyisAM索引的基数值（Cardinality，show index 命令可以看见）是精确的，InnoDB则是估计值。这里涉及到信息统计的知识，MyisAM统计信息是保存磁盘中，在alter表或Analyze table操作更新此信息，而InnoDB则是在表第一次打开的时候估计值保存在缓存区内；
MyisAM处理字符串索引时用增量保存的方式，如第一个索引是‘preform’，第二个是‘preformence’，则第二个保存是‘7，ance’，这个明显的好处是缩短索引，但是缺陷就是不支持倒序提取索引，必须顺序遍历获取索引
```


TODO List - 先给出基本的理解， 后面有时间再深入。 
1. B树， 这个还是比较复杂的如果想弄的比较清楚的话。 参考 https://blog.csdn.net/v_JULY_v/article/details/6530142/
2. 红黑树 https://blog.csdn.net/v_JULY_v/article/details/6105630
3. https://blog.csdn.net/hxpjava1/article/details/55803923 索引原理
4. https://www.cnblogs.com/shijianchuzhenzhi/p/6666537.html 索引比较


link
- https://blog.csdn.net/gui951753/article/details/79489279
- http://blog.csdn.net/weiliangliang111/article/details/51333169  - 索引
- 

